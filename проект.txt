файл EVENT_HANDLER_SERVICE/event_service.py:

import sys, pika, json, concurrent.futures, multiprocessing
import random, requests
from utilities import *

threadPool = None
channel = None
connection_pool = None
innerQueue = None
apiServiceURL = None

def start_event(target, event):
    #print(event)
    connection = connection_pool.getconn()
    returnValue = target(event, connection)
    #print(returnValue)
    connection_pool.putconn(connection)
    for request in returnValue:
        print("inner Queue", request)
        innerQueue.put(request)

def gen_new(id):
    print("HELLO FROM GENNEW")
    sys.stdout.flush()


    id = str(id)
    if id[0] == '-':
        return 0
    else:
        id = str(id)
        tmp = {"id": "", "len": "", "time": "", "name": ""}
        tmp["id"], tmp["len"], tmp["time"] = id, str(random.randint(1, 10)), str(current_day())
        # pipes = pipeQueue.get()
        # sendQueue.put(("bot", "users.get", {"user_ids": str(id)}, "CallBack", pipes))
        # nm_tmp = pipes["end"].recv()
        # pipes["end"].send("banana")
        print("Sending request")
        sys.stdout.flush()
        data = ("bot", "users.get", {"user_ids": str(id)}, "CallBack")
        nm_tmp = requests.post(apiServiceURL, json=json.dumps(data))
        # print(nm_tmp)
        # print(nm_tmp.text)
        # print(nm_tmp.json())
        # print(nm_tmp.json()["data"][0])
        # print(nm_tmp.json()["data"][0]["first_name"])
        nm_tmp = nm_tmp.json()["data"]
        print("Got data", nm_tmp)
        sys.stdout.flush()

        name = nm_tmp[0]["first_name"] + " " + nm_tmp[0]["last_name"]
        tmp["name"] = str(name)
        if tmp["name"][-12:] == " | ВКонтакте":
            tmp["name"] = tmp["name"][:-12]

        print(tmp)
        sys.stdout.flush() 
        return tmp

def delta(event, connection):

    print("HELLO FROM DELTA")
    sys.stdout.flush()

    returnValue = []
    cursor = connection.cursor()
    string = str(event["message"]["peer_id"])
    id = str(event["message"]["from_id"])
    day = current_day()
    cursor.execute("SELECT * FROM basechel WHERE peerid=%s and id=%s", [int(string), int(id)])
    chel = cursor.fetchone()
    if chel != None:
        print("NE NONE")
        sys.stdout.flush()


        chel = list(chel)
        if day - (int(chel[gtime])) < 1:
            cursor.close()
            return [("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                        "message": chel[gname] + ", ти сьогодні вже грав(",
                                        "random_id": 0}, "OneWay")]
        fin = int(chel[glen])
        ans = random.randint(-10, 10)
        if ans < 0:
            ans = random.randint(-10, 10)
        while ans == 0:
            ans = random.randint(-10, 10)
        #        print(ans, fin)
        if fin + ans <= 0:
            fin = 0
            returnValue = [("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                        "message": chel[gname] + ", у тебе відвалилася социальный рейтинг(",
                                        "random_id": 0}, "OneWay")]
        else:
            fin = fin + ans
            if ans > 0:
                returnValue = [("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                            "message": chel[gname] + ", твій социальный рейтинг виріс на " + str(
                                                ans) + " см. Тепер його довжина " + str(fin) + " см.",
                                            "random_id": 0}, "OneWay")]
            else:
                returnValue = [("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                            "message": chel[gname] + ", твій социальный рейтинг зменшився на " + str(
                                                -ans) + " см. Тепер його довжина " + str(fin) + " см.",
                                            "random_id": 0}, "OneWay")]
        chel[glen] = int(fin)
        chel[gtime] = int(current_day())
        cursor.execute("UPDATE basechel set len = %s, time = %s where globalid = %s",
                                (chel[glen], chel[gtime], chel[gglobalid]))
        connection.commit()

    if chel == None:
        print("NONE")
        sys.stdout.flush()

        new_chel = gen_new(id)
        if new_chel == 0:
            returnValue = [("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                        "message": "Боти не можуть користуватися цим ботом!",
                                        "random_id": 0}, "OneWay")]
        else:
            returnValue = [("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                        "message": new_chel["name"] + ", Вітаю в грі социальный рейтинг, ти зіграв в перший раз і "
                                                                        "зараз твій социальный рейтинг має довжину " + new_chel[
                                                        "len"] + " см.",
                                        "random_id": 0}, "OneWay")]
            tchel = (
                int(string), int(id), int(new_chel["len"]), int(new_chel["time"]), str(new_chel["name"]), 0)
            cursor.execute("INSERT INTO basechel (peerid, id, len, time, name, delta) VALUES(%s, %s, %s, %s, %s, %s)", tchel)
            connection.commit()
    cursor.close()
    print(returnValue)
    sys.stdout.flush() 
    return returnValue

def top_all(event, connection):
    returnValue = []
    cursor = connection.cursor()
    string = str(event["message"]["peer_id"])
    cursor.execute("SELECT * FROM basechel WHERE peerid=%s", (int(string),))
    chel = cursor.fetchall()
    pr = sorted(chel, key=lambda tmp: -int(tmp[glen]))
    ans = ""
    counter = 0
    tmp = 0
    flag = 1
    while flag:
        flag = 0
        while tmp < len(pr):
            counter = 0
            ans = ""
            for i in range(tmp, len(pr)):
                if counter > 4000:
                    flag = 1
                    break
                ans += str(tmp+1) + ". " + pr[i][gname] + " - " + str(pr[i][glen]) + " см." + " \n"
                counter = len(ans)
                tmp += 1
            if ans != "":
                returnValue.append(("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                            "message": ans,
                                            "random_id": 0}, "OneWay"))
        else:
            break
    cursor.close()
    return returnValue

def top(event, connection):
    returnValue = []
    #print("123125456t436743")
    cursor = connection.cursor()
    string = str(event["message"]["peer_id"])
    cursor.execute("SELECT * FROM basechel WHERE peerid=%s", (int(string),))
    chel = cursor.fetchall()
    pr = sorted(chel, key=lambda tmp: -int(tmp[glen]))
    ans = ""
    for i in range(min(10, len(pr))):
        ans += str(i+1) + ". " + pr[i][gname] + " - " + str(pr[i][glen]) + " см." + " \n"
    cursor.close()
    if ans != "":
        returnValue = [("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                "message": ans,
                                "random_id": 0}, "OneWay")]
    return returnValue

def rand_gachi_text():
    gachi = ["Гей, приятель, я думаю, ти помилився дверима, Шкіряний клуб знаходиться в двох кварталах звідси." + "\n ",
                "трахнути тебе♂" + "\n ",
                "Ох, та пішов ти, Шкіряний мужик. Може бути, нам з тобою варто залагодити це прямо тут, на рингу, якщо ти вважаєш себе таким крутим." + "\n ",
                "Ха! Так, правильно, хлопець. Пішли звідси! Чому б тобі не позбутися від цієї шкіряної гидоти%s Я зараз роздягнуся, і ми всі владнаємо прямо тут, на рингу. А ти що скажеш%s" + "\n"]
    tmp = str(random.choice(gachi))
    return tmp

def TechRab(event, connection):
    return [("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                "message": "Тыкни попозже, ведутся техработы.",
                                "random_id": 0}, "OneWay")]

def roll(event, connection):
    cursor = connection.cursor()
    id = str(event["message"]["from_id"])
    string = str(event["message"]["peer_id"])
    arr = ['0 0 1', '0 0 2', '0 0 3', '0 0 4', '0 0 5', '0 0 6', '0 0 7', '0 0 8', '0 0 9', '0 1 0', '0 1 1', '0 1 2',
            '0 1 3', '0 1 4', '0 1 5', '0 1 6', '0 1 7', '0 1 8', '0 1 9', '0 2 0', '0 2 1', '0 2 2', '0 2 3', '0 2 4',
            '0 2 5', '0 2 6', '0 2 7', '0 2 8', '0 2 9', '0 3 0', '0 3 1', '0 3 2', '0 3 3', '0 3 4', '0 3 5', '0 3 6',
            '0 3 7', '0 3 8', '0 3 9', '0 4 0', '0 4 1', '0 4 2', '0 4 3', '0 4 4', '0 4 5', '0 4 6', '0 4 7', '0 4 8',
            '0 4 9', '0 5 0', '0 5 1', '0 5 2', '0 5 3', '0 5 4', '0 5 5', '0 5 6', '0 5 7', '0 5 8', '0 5 9', '0 6 0',
            '0 6 1', '0 6 2', '0 6 3', '0 6 4', '0 6 5', '0 6 6', '0 6 7', '0 6 8', '0 6 9', '0 7 0', '0 7 1', '0 7 2',
            '0 7 3', '0 7 4', '0 7 5', '0 7 6', '0 7 7', '0 7 8', '0 7 9', '0 8 0', '0 8 1', '0 8 2', '0 8 3', '0 8 4',
            '0 8 5', '0 8 6', '0 8 7', '0 8 8', '0 8 9', '0 9 0', '0 9 1', '0 9 2', '0 9 3', '0 9 4', '0 9 5', '0 9 6',
            '0 9 7', '0 9 8', '0 9 9', '1 0 0']
    chislo = arr[random.randint(0, 99)]
    cursor.execute("SELECT * FROM basechel WHERE peerid=%s and id=%s", (int(string), int(id)))
    chel = cursor.fetchone()
    cursor.close()
    if chel == None:
        return [("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                    "message": "Гарний хлопець получает случайное число(1-100):  " + chislo,
                                    "random_id": 0}, "OneWay")]
    else:
        return [("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                    "message": chel[gname] + " получает случайное число(1-100):  " + chislo,
                                    "random_id": 0}, "OneWay")]

def summarry(event, connection):
    cursor = connection.cursor()
    string = str(event["message"]["peer_id"])
    cursor.execute("SELECT * FROM basechel WHERE peerid=%s", (int(string),))
    chel = cursor.fetchall()
    summ = 0
    for i in chel:
        summ += int(i[glen])
    cursor.close()
    return [("bot", "messages.send", {"peer_id": event["message"]["peer_id"],
                                "message": "Довжина социального рейтинга вашого чату " + str(
                                    summ) + " см.",
                                "random_id": 0}, "OneWay")]

def sound(event, connection):
    print("HELLO FROM SOUND")
    sys.stdout.flush() 
    with open ('tracks.txt', 'r') as f:
        arr_track = f.readlines()
        string = str(event["message"]["peer_id"])
        return [("bot", "messages.send", {"peer_id": string,
                                        "message": rand_gachi_text(),
                                        "attachment": f"audio{-193557157}_{str(random.choice(arr_track))}",
                                        "random_id": random.randint(1, 2147483647)}, "OneWay")]

def my_rating(event, connection):
    cursor = connection.cursor()
    string = str(event["message"]["peer_id"])
    id = str(event["message"]["from_id"])
    cursor.execute("SELECT * FROM basechel WHERE peerid=%s and id=%s", (int(string), int(id)))
    chel = cursor.fetchone()
    if chel == None:
        cursor.close()
        return [("bot", "messages.send", {"peer_id": string,
                                    "message": "Пробач, брате, але в тебе ще немає социального рейтинга",
                                    "random_id": 0}, "OneWay")]
    else:
        cursor.close()
        return [("bot", "messages.send", {"peer_id": string,
                                    "message": chel[gname] + ", довжина твого социального рейтинга " + str(chel[glen]) + " см.",
                                    "random_id": 0}, "OneWay")]

def remove_rating(event, connection):
    cursor = connection.cursor()
    string = str(event["message"]["peer_id"])
    id = str(event["message"]["from_id"])
    cursor.execute("SELECT * FROM basechel WHERE peerid=%s and id=%s", (int(string), int(id)))
    chel = cursor.fetchone()
    if chel == None:
        returnValue = [("bot", "messages.send", {"peer_id": string,
                                    "message": "Пробач, брате, але в тебе ще немає социального рейтинга",
                                    "random_id": 0}, "OneWay")]
    else:
        cursor.execute("DELETE FROM basechel WHERE peerid=%s and id=%s", (int(string), int(id)))
        returnValue = [("bot", "messages.send", {"peer_id": string,
                                    "message": chel[gname] + ", вітаю, ти відрізав собі социальный рейтинг. Назавжди!",
                                    "random_id": 0}, "OneWay")]
    connection.commit()
    cursor.close()
    return returnValue

def callback(ch, method, properties, body):
    event = json.loads(body)
    #print(" [x] Received %r" % data)
    #sys.stdout.flush()
    try: 
        if debug and event["message"]["text"][0] == "/":
            threadPool.submit(start_event, TechRab, event)

        elif event["message"]["text"].lower() == "/социальный_рейтинг":
            threadPool.submit(start_event, delta, event)
        elif event["message"]["text"].lower() == "/топ":
            threadPool.submit(start_event, top, event)
        elif event["message"]["text"].lower() == "/топ_все":
            threadPool.submit(start_event, top_all, event)
        elif event["message"]["text"].lower() == "/ролл":
            threadPool.submit(start_event, roll, event)
        elif event["message"]["text"].lower() == "/чат":
            threadPool.submit(start_event, summarry, event)
        elif event["message"]["text"].lower() == "/микс":
            threadPool.submit(start_event, sound, event)
        elif event["message"]["text"].lower() == "/мой_социальный_рейтинг":
            threadPool.submit(start_event, my_rating, event)
        elif event["message"]["text"].lower() == "/маргинализация":
            threadPool.submit(start_event, remove_rating, event)
    except Exception as excpt:
        print(excpt)
        sys.stdout.flush()

def innerQueueManager(innerQueue, isProdigy):
    while True:
        try:
            while True:
                try:
                    connection = pika.BlockingConnection(pika.ConnectionParameters('rabbitmq' if isProdigy == False else 'rabbitmq_dev'))
                    channel = connection.channel()
                    break
                except Exception:
                    print("Failed to connect to RabbitMQ")
                    sys.stdout.flush()
                    time.sleep(2)
                    continue

            channel.queue_declare(queue='sendQueue')

            while True:
                event = innerQueue.get()
                print("innerQueueManager", event)
                sys.stdout.flush()
                channel.basic_publish(exchange='', routing_key='sendQueue', body=json.dumps(event))
                
        except Exception as excpt:
            print("innerQueueManager", excpt)
            sys.stdout.flush()

if __name__ == "__main__":

    isLocal = int(sys.argv[1])
    isProdigy = int(sys.argv[2])
    debug = int(sys.argv[3])

    apiServiceURL = "http://vk_api_send_dev:7331/api" if isProdigy else "http://vk_api_send:7331/api"

    while True:
        try:
            connection = pika.BlockingConnection(pika.ConnectionParameters('rabbitmq' if isProdigy == False else 'rabbitmq_dev'))
            channel = connection.channel()
            break
        except Exception:
            print("Failed to connect to RabbitMQ")
            sys.stdout.flush()
            time.sleep(2)
            continue

    channel.queue_declare(queue='eventQueue')


    threadPool = concurrent.futures.ThreadPoolExecutor(max_workers=32)
    connection_pool = StartDB(isProdigy, isLocal)
    innerQueue = multiprocessing.Queue(maxsize=1000)

    innerQueueProcess = multiprocessing.Process(target=innerQueueManager, args=(innerQueue, isProdigy,))
    innerQueueProcess.start()

#def eventManager(eventQueue, isProdigy, isLocal, sendQueue, pipeQueue, debug):

    if debug:
        test_event = {'message': {'date': 1669403763, 'from_id': 231688699, 'id': 0, 'out': 0, 'attachments': [], 'conversation_message_id': 610, 'fwd_messages': [], 'important': False, 'is_hidden': False, 'peer_id': 2000000001, 'random_id': 0, 'text': '/топ'}, 'client_info': {'button_actions': ['text', 'vkpay', 'open_app', 'location', 'open_link', 'callback', 'intent_subscribe', 'intent_unsubscribe'], 'keyboard': True, 'inline_keyboard': True, 'carousel': True, 'lang_id': 0}}
        threadPool.submit(start_event, delta, test_event)
        threadPool.submit(start_event, top, test_event)
        threadPool.submit(start_event, top_all, test_event)
        threadPool.submit(start_event, roll, test_event)
        threadPool.submit(start_event, summarry, test_event)
        threadPool.submit(start_event, sound, test_event)
        threadPool.submit(start_event, my_rating, test_event)
        threadPool.submit(start_event, remove_rating, test_event)

    channel.basic_consume(queue='eventQueue',
                      auto_ack=True,
                      on_message_callback=callback)

    print("EventManager STARTED!")
    sys.stdout.flush()

    channel.start_consuming()



файл EVENT_HANDLER_SERVICE/Dockerfile:

FROM python:3.11-slim

WORKDIR "/social_rating_Kraft_Bot"

COPY . ./

RUN pip install --no-cache-dir -r requirements.txt

CMD python3 event_service.py ${LOCAL} ${PRODIGY} ${DEBUG}




файл VK_API_EVENT_SERVICE/vk_api_event_service.py:

import random, vk_api, os, time, sys, pika, json
from vk_api.bot_longpoll import VkBotEventType, VkBotLongPoll


def AutificationMain(isProdigy):
    global LP
    if isProdigy:
        RUN = open('RUNProdigy.txt', 'r')
        RUN_arr = RUN.readlines()
        vk = vk_api.VkApi(token=RUN_arr[0][:-1])
        vk._auth_token()
        LP = VkBotLongPoll(vk, RUN_arr[1])
        RUN.close()
        return LP
    else:
        RUN = open('RUN.txt', 'r')
        RUN_arr = RUN.readlines()
        vk = vk_api.VkApi(token=RUN_arr[0][:-1])
        vk._auth_token()
        LP = VkBotLongPoll(vk, RUN_arr[1])
        RUN.close()
        return LP


def auth_handler():
    key = input("Enter authentication code: ")
    remember_device = True
    return key, remember_device

if __name__ == "__main__":

    # time.sleep(30)

    # eventQueue = multiprocessing.Queue(maxsize=1000)
    # sendQueue = multiprocessing.Queue(maxsize=1000)
    # pipeQueue = multiprocessing.Queue(maxsize=100)
    # for i in range(50):
    #     pipeST , pipeED = multiprocessing.Pipe()
    #     tmp = {"start" : pipeST, "end" : pipeED}
    #     pipeQueue.put(tmp)
    isLocal = int(sys.argv[1])
    isProdigy = int(sys.argv[2])
    debug = int(sys.argv[3])

    while True:
        try:
            connection = pika.BlockingConnection(pika.ConnectionParameters('rabbitmq' if isProdigy == False else 'rabbitmq_dev'))
            channel = connection.channel()
            break
        except Exception:
            print("Failed to connect to RabbitMQ")
            sys.stdout.flush()
            time.sleep(2)
            continue

    channel.queue_declare(queue='eventQueue')
    channel.queue_declare(queue='sendQueue')


    LP = AutificationMain(isProdigy)

    # try:
    #     f = open('timing.txt', 'r')
    # except Exception:
    #     f = open('timing.txt', 'w')
    #     f.write("100")
    #     f.close()
    #     f = open('timing.txt', 'r')
    # TMP = int(f.readline())
    # f.close()

    # apiServiceProcess = multiprocessing.Process(target=apiService, args=(sendQueue, pipeQueue, isProdigy, debug,))
    # eventManagerProcess = multiprocessing.Process(target=eventManager, args=(eventQueue, isProdigy, isLocal, sendQueue, pipeQueue, debug,))
    # dailyTasksProcess = multiprocessing.Process(target=dailyTasks, args=(isProdigy, isLocal, sendQueue, pipeQueue, debug,))
    # apiServiceProcess.start()
    # eventManagerProcess.start()
    # dailyTasksProcess.start()

    commands = ["/социальный_рейтинг", "/топ", "/топ_все", "/ролл", "/чат", "/микс", "/мой_социальный_рейтинг", "/маргинализация"]

    while True:
        print("Ready")
        sys.stdout.flush()
        try:
            for event in LP.listen():

                if event.type == VkBotEventType.MESSAGE_NEW:
                    text = event.object["message"]["text"].lower()
                    if event.object["message"]["peer_id"] != event.object["message"]["from_id"]:
                        if text in commands:
                            channel.basic_publish(exchange='', routing_key='eventQueue', body=json.dumps(dict(event.object)))
                            #eventQueue.put(dict(event.object))

                    elif event.object["message"]["peer_id"] == event.object["message"]["from_id"]:
                        if text == "" or text[0] == "/" or text == "начать":
                            request = ("bot", "messages.send",
                                      {"peer_id": event.object["message"]["from_id"],
                                       "message": "Дружище, наш бот работает только в беседах. Здесь ты можешь задать вопрос разработчикам. Подпишись на нашу группу, чтобы не пропускать новости разработки и ежедневные топы бесед, а пока держи гайд: https://vk.com/@social_rating_kraftbot-itak-prishlo-vremya-napisat-podrobnyi-gaid-na-bota",
                                       "random_id": random.randint(1, 2147483647)}, "OneWay")
                            channel.basic_publish(exchange='', routing_key='sendQueue', body=json.dumps(list(event.request)))
                            #sendQueue.put(request)
                        else:
                            continue
                elif event.type == "donut_subscription_create":
                    print("Мама, ноый донат)")
                elif event.type == "donut_subscription_expired":
                    print("Блин, минус дон(")

        except Exception as excpt:
            try:
                connection.close()
            except Exception as excpt:
                print("conndrop", excpt)
                
            while True:
                try:
                    connection = pika.BlockingConnection(pika.ConnectionParameters('rabbitmq' if isProdigy == False else 'rabbitmq_dev'))
                    channel = connection.channel()
                    break
                except Exception:
                    print("Failed to connect to RabbitMQ")
                    sys.stdout.flush()
                    time.sleep(2)
                    continue

            channel.queue_declare(queue='eventQueue')
            channel.queue_declare(queue='sendQueue')

            try:
                LP = AutificationMain(isProdigy)
                print("LP update")
            except Exception as excpt:
                print("ну иди выключи компьютер")
            print(excpt)

        time.sleep(1)




файл VK_API_EVENT_SERVICE/Dockerfile:

FROM python:3.11-slim

WORKDIR "/social_rating_Kraft_Bot"

COPY . ./

RUN pip install --no-cache-dir -r requirements.txt

CMD python3 vk_api_event_service.py ${LOCAL} ${PRODIGY} ${DEBUG}




файл VK_API_SEND_SERVICE/vkApiService.py:

import vk_api, multiprocessing, time, sys, pika, concurrent.futures, json
from starlette.applications import Starlette
from starlette.requests import Request
from starlette.responses import JSONResponse
import uvicorn

innerQueue = multiprocessing.Queue()
isLocal = None
isProdigy = None
debug = None
API = None
threadPool = None
def Autification(isProdigy):
    if isProdigy:
        RUN = open('RUNProdigy.txt', 'r')
        RUN_arr = RUN.readlines()
        vk = vk_api.VkApi(token=RUN_arr[0][:-1])
        vk._auth_token()
        RUN.close()
        return vk
    else:
        RUN = open('RUN.txt', 'r')
        RUN_arr = RUN.readlines()
        vk = vk_api.VkApi(token=RUN_arr[0][:-1])
        vk._auth_token()
        RUN.close()
        return vk


def adminAuth():
    vk_admin = vk_api.VkApi('+79163447672',
                            token="vk1.a.lEFtR2sMDqZDSfZIJ6wGjr1Tr56tDt0QFUUgX248ET51rrBQw12gxFqXxLTanLOeCvAMg6P2ezUyCW3myZItZKcgO6KRaWq81sT1mpjPU9BEFU0BTdvtQ6VR9AeQ3CrzX84fXG9BOC0p3P0I6F0kJbdUfZhPNk33h2XG-DZUFvlYd-5j6ZBg06FBiSj5n8UO2scrm8XUdzdLUIppQlNHcA")
    vk_admin.get_api()
    return vk_admin


class ApiService:
    def __init__(self, isProdigy):
        self.isProdigy = isProdigy
        self.vk = Autification(isProdigy)
        self.vk_admin = adminAuth()
        self.vk.RPS_DELAY = 0.051

    def safe_executer(self, event, admin, type):
        if type == "execute":
            func = self.execute
        elif type == "execute_cb":
            func = self.execute_cb
        elif type == "is_admin":
            func = self.is_admin

        flag = 10
        while flag:
            try:
                func(event, admin)
                flag = 0
            except Exception as cal:
                print(cal, "in safe executer", event)
                sys.stdout.flush()
                flag -= 1
                time.sleep(1)




    def execute(self, event, admin):
        if admin:
            self.vk_admin.method(event[1], event[2])
        else:
            self.vk.method(event[1], event[2])

    def execute_cb(self, event, admin):
        pipe = event[4]["start"]
        if admin:
            tmp = self.vk_admin.method(event[1], event[2])
        else:
            tmp = self.vk.method(event[1], event[2])
        pipe.send(tmp)

    def is_admin(self, event, admin):
        try:
            self.vk.method(event[1], event[2])
            pipe = event[4]["start"]
            pipe.send(True)
        except Exception:
            pipe = event[4]["start"]
            pipe.send(False)


def callback_MQ(ch, method, properties, body):
    try:
        request = json.loads(body)
        innerQueue.put(request)
        print("Received by MQ:", request)
        sys.stdout.flush()
    except Exception as excpt:
        print("MQ error", excpt)
        sys.stdout.flush()

def prosessRequest(request):
    if debug and request[1] != "messages.send":
        print("sending", request)
        sys.stdout.flush()

    if request[0] == "bot":
        if request[3] == "OneWay":
            API.safe_executer(request, 0, "execute")
        else:
            API.safe_executer(request, 0, "execute_cb")
    elif request[0] == "admin":
        if request[3] == "OneWay":
            API.safe_executer(request, 1, "execute")
        else:
            API.safe_executer( request, 1, "execute_cb")
    else:
        threadPool.submit(API.safe_executer, request, 1, "is_admin")

def rabbitQueueReader(innerQueue, isProdigy):
    while True:
        try: 
            while True:
                try:
                    connection = pika.BlockingConnection(pika.ConnectionParameters('rabbitmq' if isProdigy == False else 'rabbitmq_dev'))
                    channel = connection.channel()
                    break
                except Exception:
                    print("Failed to connect to RabbitMQ")
                    sys.stdout.flush()
                    time.sleep(2)
                    continue
            channel.queue_declare(queue='sendQueue')
            channel.basic_consume(queue='sendQueue',
                            auto_ack=True,
                            on_message_callback=callback_MQ)
            channel.start_consuming()
        except Exception as excpt:
            print("rabbitQueueReader", excpt)
            sys.stdout.flush()
            time.sleep(1)
            continue

def restfulApiReader(innerQueue):
    app = Starlette()

    @app.route("/api", methods=["POST"])
    async def event(request: Request):
        print("HELLO FROM STARLETTE")
        sys.stdout.flush()
        data = await request.json()
        event = json.loads(data)
        print("Received by REST:", event)
        sys.stdout.flush()
        pipeST, pipeED = multiprocessing.Pipe()
        tmp = {"start" : pipeST, "end" : pipeED}
        event.append(tmp)
        innerQueue.put(event)

        # Process data
        response = {"data": pipeED.recv()}
        pipeST.close()
        pipeED.close()
        print("Response:", response)
        sys.stdout.flush()

        return JSONResponse(response)

    uvicorn.run(app, host="0.0.0.0", port=7331)

if __name__ == "__main__":

    isLocal = int(sys.argv[1])
    isProdigy = int(sys.argv[2])
    debug = int(sys.argv[3])

    API = ApiService(isProdigy)

    restfulApiReaderProcess = multiprocessing.Process(target=restfulApiReader, args=(innerQueue,))
    rabbitQueueReaderProcess = multiprocessing.Process(target=rabbitQueueReader, args=(innerQueue, isProdigy,))

    restfulApiReaderProcess.start()
    rabbitQueueReaderProcess.start()

    threadPool = concurrent.futures.ThreadPoolExecutor(max_workers=32)

    print("API_SEND_SERVICE STARTED")
    sys.stdout.flush()

    while True:
        try:
            while True:
                data = innerQueue.get()
                print("innnerQueue QE", data)
                sys.stdout.flush()
                prosessRequest(data)
        except Exception as excpt:
            API = ApiService(isProdigy)
            time.sleep(1)
            print("vkApiService", excpt)
            sys.stdout.flush()




файл VK_DAILY_SERVICE/Dockerfile:

FROM python:3.11-slim

WORKDIR "/social_rating_Kraft_Bot"

COPY . ./

RUN pip install --no-cache-dir -r requirements.txt

CMD python3 daily_service.py ${LOCAL} ${PRODIGY} ${DEBUG}




файл VK_DAILY_SERVICE/daily_service.py:

import requests, concurrent.futures, time, sys, pika, json, multiprocessing, re, os, random, datetime, threading, concurrent.futures, json
from utilities import *
from bs4 import BeautifulSoup

connection = None
channel = None
apiServiceURL = None

class Daily:
    def __init__(self, isProdigy, isLocal, debug):
        self.debug = debug
        self.isProdigy = isProdigy
        self.connection_pool = StartDB(isProdigy, isLocal)
        self.threads = concurrent.futures.ThreadPoolExecutor(max_workers=5)
        self.run_arr = getRUN_arr(isProdigy)
        

    def start(self):
        while True:
            channel.basic_publish(exchange='', routing_key='heartbeat', body='heartbeat')
            time.sleep(5)
            try:
                f = open('timing.txt', 'r')
                TMP = int(f.readline())
                f.close()
                if current_hour() == 12 and TMP - current_day() < 0 or self.debug:
                    self.debug = 0
                    print("TOPS")
                    TMP = current_day()
                    f = open('timing.txt', 'w')
                    f.write(str(current_day()))
                    f.close()

                    connection_top_print = self.connection_pool.getconn()
                    connection_top_chel = self.connection_pool.getconn()
                    connection_remove_old = self.connection_pool.getconn()

                    st, ed = multiprocessing.Pipe()
                    pipes_top_chel = {"start": st, "end": ed}
                    st, ed = multiprocessing.Pipe()
                    pipes_top_print = {"start": st, "end": ed}
                    st, ed = multiprocessing.Pipe()
                    pipes_remove_old = {"start": st, "end": ed}

                    self.threads.submit(self.top_chel, connection_top_chel, pipes_top_chel)
                    self.threads.submit(self.top_print, connection_top_print, pipes_top_print)
                    self.threads.submit(self.remove_old, connection_remove_old, pipes_remove_old)
                    self.threads.submit(self.reload_audio)

                    if pipes_top_chel["end"].recv() and \
                            pipes_top_print["end"].recv() and \
                            pipes_remove_old["end"].recv():

                        pipes_top_print["start"].close()
                        pipes_top_chel["start"].close()
                        pipes_remove_old["start"].close()
                        pipes_top_print["end"].close()
                        pipes_top_chel["end"].close()
                        pipes_remove_old["end"].close()

                        self.connection_pool.putconn(connection_top_chel)
                        self.connection_pool.putconn(connection_top_print)
                        self.connection_pool.putconn(connection_remove_old)
                        print("Done SUKA!!!")
            except Exception as excpt:
                print(excpt, "from DAILY")
                sys.stdout.flush()



    def reload_audio(self, pipes_remove_old):
        print("reload audio")
        ssyl = "https://vk.com/music/playlist/-193557157_1"
        html_doc = requests.get(ssyl).text
        soup = BeautifulSoup(html_doc, features="html.parser")
        arr_track = []
        for track in soup.find('div', 'AudioPlaylistRoot').find_all('div', 'audio_item'):
            tmp = str(track)[45:54]
            arr_track.append(str(tmp))
        f = open('tracks.txt', 'w')
        for i in range(len(arr_track) - 1):
            f.write(str(arr_track[i]))
            f.write(" \n")
        f.write(arr_track[-1])
        f.close()
        pipes_remove_old["start"].send("pepper")

    def is_admin(self, peer_id):
        data = ("is_admin_check", "messages.getConversationMembers", {"peer_id": peer_id}, "CallBack")
        check = requests.post(apiServiceURL, json=json.dumps(data)).json()["data"]
        return check

    def del_post(self, name):
        print("Deliting")
        f = open(name, 'r')
        tmp = f.readlines()
        tmp = tmp[0].split()
        tmp = tmp[1][:-1]
        f.close()

        event = ("admin", "wall.delete",
                        {"owner_id": "-" + self.run_arr[1], "post_id": tmp}, "OneWay")

        channel.basic_publish(exchange='', routing_key='sendQueue', body=json.dumps(event))

    def top_chel(self, connection, pipes_top_chel):
        print("top_chel")
        cursor = connection.cursor()
        cursor.execute("SELECT * FROM basechel ORDER BY len DESC")
        chel = cursor.fetchall()
        ans = []
        for i in chel:
            if self.is_admin(i[gpeerid]):
                besed_id = i[gpeerid]
                data = ("bot", "messages.getConversationsById", {"peer_ids": besed_id}, "CallBack")
                name = requests.post(apiServiceURL, json=json.dumps(data)).json()["data"]
                name = name["items"][0]["chat_settings"]["title"]
            else:
                name = "-"
            tmp = [i, name]

            ans.append(tmp)

            if len(ans) == 11:
                break
        s = "Лучшие челы сегодня:" + "\n" + "\n"
        for i in range(len(ans)):
            j = ans[i][0]
            s += str(str(i + 1) + ". " + j[gname] + " - " + str(j[glen]) + " см." + " (" + ans[i][1] + ")" + '\n')
        if self.isProdigy == False:
            self.del_post("Chels_ID.txt")
        data = ("admin", "wall.post", {
            "owner_id": "-" + self.run_arr[1],
            "message": s,
            "from_group": 1
        }, "CallBack")
        ID = requests.post(apiServiceURL, json=json.dumps(data)).json()["data"]
        if self.isProdigy == False:
            f = open('Chels_ID.txt', 'w')
            f.write(str(ID))
            f.close()
        pipes_top_chel["start"].send("pepper")


    def top_print(self, connection, pipes_top_print):
        print("top_print")
        cursor = connection.cursor()
        cursor.execute("SELECT * FROM basechel")
        chels = cursor.fetchall()
        tops = {}
        for chel in chels:
            peerid = chel[gpeerid]
            ln = chel[glen]
            nowlen = tops.get(peerid)
            if nowlen == None:
                tops.update({peerid: ln})
            else:
                tops.update({peerid: nowlen + ln})
        ans = [[i, j] for i, j in sorted(tops.items(), key=lambda item: -item[1])]
        tmp = []
        for i in range(min(len(ans), 100)):
            peerid = ans[i][0]
            if self.is_admin(peerid):
                data = ("bot", "messages.getConversationsById", {"peer_ids": peerid}, "CallBack")
                name = requests.post(apiServiceURL, json=json.dumps(data)).json()["data"]
                name = name["items"][0]["chat_settings"]["title"]
                tmp.append([ans[i][1], name])
            if len(tmp) == 9:
                break
        tmpe = "Лучшие чаты сегодня:" + "\n" + "\n"

        for i in range(len(tmp)):
            tmpe += str(i + 1) + ". " + str(tmp[i][-1]) + ", довжина социального рейтинга вашого чату - " + str(tmp[i][0]) + " см." + "\n"
        if self.isProdigy == False:
            self.del_post("Chats_ID.txt")
        data = ("admin", "wall.post", {
            "owner_id": "-" + self.run_arr[1],
            "message": tmpe,
            "from_group": 1
        }, "CallBack")
        ID = requests.post(apiServiceURL, json=json.dumps(data)).json()["data"]
        if self.isProdigy == False:
            f = open('Chats_ID.txt', 'w')
            f.write(str(ID))
            f.close()
        pipes_top_print["start"].send("pepper")



    def remove_old(self, connection):
        print("remove old")
        cursor = connection.cursor()
        cursor.execute("SELECT * FROM basechel WHERE time<%s", (current_day() - 365))
        chel = cursor.fetchall()
        for i in chel:
            cursor.execute("DELETE FROM basechel WHERE peerid=%s and id=%s", (i[gpeerid], i[gid]))
        connection.commit()

if __name__ == '__main__':
    print("dailyTasks")
    sys.stdout.flush()
    isLocal = int(sys.argv[1])
    isProdigy = int(sys.argv[2])
    debug = int(sys.argv[3])


    apiServiceURL = "http://vk_api_send_dev:7331/api" if isProdigy else "http://vk_api_send:7331/api" 
    while True:
                try:
                    connection = pika.BlockingConnection(pika.ConnectionParameters('rabbitmq' if isProdigy == False else 'rabbitmq_dev'))
                    channel = connection.channel()
                    break
                except Exception:
                    print("Failed to connect to RabbitMQ")
                    sys.stdout.flush()
                    time.sleep(2)
                    continue

    channel.queue_declare(queue='sendQueue')


    try:
        tasks = Daily(isProdigy, isLocal, debug)
        tasks.start()
    except Exception as excpt:
        print("dailyTasks", excpt)



файл docker-compose.yml:

version: "3.8"

services:

  rabbitmq:
    image: rabbitmq:3-management 
    ports:
      - 5672:5672
      - 15672:15672
    networks:
      - dkb

  db:
    container_name: db
    image: postgres:16
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PW} 
    ports:
      - 5432:5432
    restart: always
    networks:
      - dkb
    volumes:
      - ./containers_data/db:/var/lib/postgresql/data
      - ./DB_SERVICE:/docker-entrypoint-initdb.d
  
  vk_api_send:
    container_name: vk_api_send
    build:
      context: ./VK_API_SEND_SERVICE
    restart: always
    networks:
      - dkb
    ports:
      - 7331:7331
    environment:
      - DEBUG=${DEBUG}
      - PRODIGY=${PRODIGY}
      - LOCAL=${LOCAL}
    depends_on:
      - rabbitmq
    
  vk_daily:
    container_name: social_rating_kraft_bot_vk_daily
    build:
      context: ./VK_DAILY_SERVICE
    restart: always
    networks:
      - dkb
    environment:
      - DEBUG=${DEBUG}
      - PRODIGY=${PRODIGY}
      - LOCAL=${LOCAL}
    depends_on:
      - db
      - rabbitmq

  event_handler:
    container_name: event_handler
    build:
      context: ./EVENT_HANDLER_SERVICE
    restart: always
    networks:
      - dkb
    environment:
      - DEBUG=${DEBUG}
      - PRODIGY=${PRODIGY}
      - LOCAL=${LOCAL}
    depends_on:
      - db
      - rabbitmq

  vk_api_event:
    container_name: vk_api_event
    build:
      context: ./VK_API_EVENT_SERVICE
    restart: always
    networks:
      - dkb
    environment:
      - DEBUG=${DEBUG}
      - PRODIGY=${PRODIGY}
      - LOCAL=${LOCAL}
    depends_on:
      - db
      - rabbitmq

  pgadmin:
    container_name: pgadmin 
    image: dpage/pgadmin4:latest
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_MAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PW} 
    ports:
      - 5050:80
    restart: always
    networks:
      - dkb
    user: "${UID}:${GID}"
    volumes:
      - ./containers_data/pgadmin:/var/lib/pgadmin
    depends_on:
      - db

networks:
  dkb:
    driver: bridge


